generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ProfileType {
  PATIENT
  DONOR
}

enum AllocationStatus {
  PENDING
  MATCHED
  CLAIMED
  EXPIRED
}

enum CampaignStatus {
  ACTIVE
  COMPLETED
  DELETED
}

enum AppointmentStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TransactionType {
  DONATION
  APPOINTMENT
  PAYOUT
  REFUND
}

model User {
  id             String   @id @default(uuid())
  fullName           String
  email          String   @unique
  phone          String?
  passwordHash   String
  // profile        ProfileType @default(PATIENT)
  createdAt      DateTime @default(now())
  passwordResetTokens PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]

  patientProfile PatientProfile?
  donorProfile   DonorProfile?

  waitlists      Waitlist[]        @relation("UserWaitlists")
  donationCampaigns DonationCampaign[] @relation("UserDonationCampaigns")
  donationAllocations DonationAllocation[] @relation("UserDonationAllocations")
  appointments   Appointment[]     @relation("UserAppointments")
  notifications    NotificationRecipient[]
}

model PatientProfile {
  id         String   @id @default(uuid())
  userId     String   @unique
  gender     String?
  dateOfBirth DateTime
  city       String?
  state      String?
  emailVerified  DateTime?


  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model DonorProfile {
  id                String   @id @default(uuid())
  userId            String   @unique
  organizationName  String?
  country           String?
  emailVerified  DateTime?


  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Admins {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
}

model ServiceCenter {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String
  createdAt     DateTime @default(now())
  phone         String?
  centerName    String
  address       String
  state         String
  lga           String
  // approvedStaff CenterStaff[]
  bankAccount   String?
  bankName      String?
  status        ServiceCenterStatus @default(INACTIVE)

  staff         CenterStaff[]
  appointments  Appointment[]
  services      ScreeningType[]

  invitations   CenterStaffInvite[]
}

enum ServiceCenterStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model ScreeningType {
  id                      String   @id @default(uuid())
  name                    String
  description             String?
  screeningTypeCategoryId String
  active                  Boolean  @default(true)

  category                ScreeningTypeCategory @relation(fields: [screeningTypeCategoryId], references: [id], onDelete: Restrict)
  appointments            Appointment[]
  waitlists               Waitlist[]
  campaigns               DonationCampaign[] @relation("DonationCampaignScreeningTypes")
  centers                 ServiceCenter[]
}

model ScreeningTypeCategory {
  id          String @id @default(uuid())
  name        String
  description String?

  types       ScreeningType[]
}

model Waitlist {
  id              String           @id @default(uuid())
  screeningTypeId String
  patientId       String
  status          AllocationStatus
  joinedAt        DateTime         @default(now())
  claimedAt       DateTime?

  screening       ScreeningType    @relation(fields: [screeningTypeId], references: [id], onDelete: Restrict)
  patient         User             @relation("UserWaitlists", fields: [patientId], references: [id], onDelete: Cascade)
  allocation      DonationAllocation?
}

model DonationCampaign {
  id              String           @id @default(uuid())
  donorId         String
  initialAmount   Float
  availableAmount Float
  reservedAmount  Float
  purpose         String?
  targetGender    Boolean?
  targetAgeRange  String?
  targetState     String?
  targetLga       String?
  status          CampaignStatus
  createdAt       DateTime         @default(now())

  donor           User             @relation("UserDonationCampaigns", fields: [donorId], references: [id], onDelete: Cascade)
  allocations     DonationAllocation[]
  transactions    Transaction[]    @relation("DonationTransactions")
  screeningTypes  ScreeningType[]  @relation("DonationCampaignScreeningTypes")
}

model DonationAllocation {
  id            String      @id @default(uuid())
  waitlistId    String      @unique
  appointmentId String?
  patientId     String
  campaignId    String
  claimedAt     DateTime?

  waitlist      Waitlist    @relation(fields: [waitlistId], references: [id], onDelete: Cascade)
  appointment   Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
  patient       User        @relation("UserDonationAllocations", fields: [patientId], references: [id], onDelete: Cascade)
  campaign      DonationCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
}

model Appointment {
  id                      String   @id @default(uuid())
  patientId               String
  centerId                String
  screeningTypeId         String
  donationId              String?
  isDonation              Boolean  @default(false)
  appointmentDate         DateTime
  appointmentTime         DateTime
  transactionId           String? 
  status                  AppointmentStatus
  createdAt               DateTime @default(now())
  cancellationReason   String?
  cancellationDate     DateTime?
  checkInCode             String   @unique
  checkInCodeExpiresAt    DateTime?

  patient                 User     @relation("UserAppointments", fields: [patientId], references: [id], onDelete: Cascade)
  center                  ServiceCenter @relation(fields: [centerId], references: [id], onDelete: Restrict)
  screeningType           ScreeningType @relation(fields: [screeningTypeId], references: [id], onDelete: Restrict)
  transaction             Transaction?  @relation("TransactionAppointments", fields: [transactionId], references: [id], onDelete: SetNull)
  verification            AppointmentVerification? @relation("AppointmentVerificationAppointment")
  result                  ScreeningResult? @relation("ScreeningResultAppointment")
  allocation              DonationAllocation[]
}

model AppointmentVerification {
  id             String   @id @default(uuid())
  verifiedBy     String?
  verifiedAt     DateTime

  appointment Appointment @relation("AppointmentVerificationAppointment", fields: [id], references: [id], onDelete: Cascade)
  verifier CenterStaff? @relation("StaffVerifications", fields: [verifiedBy], references: [id], onDelete: SetNull)
}

model ScreeningResult {
  id            String   @id @default(uuid())
  appointmentId String   @unique
  notes         String?
  uploadedBy    String?
  uploadedAt    DateTime @default(now())

  appointment Appointment @relation("ScreeningResultAppointment", fields: [appointmentId], references: [id], onDelete: Cascade)
  uploader    CenterStaff? @relation("StaffUploadedResults", fields: [uploadedBy], references: [id], onDelete: SetNull)
  files       ScreeningResultFile[]
}

model ScreeningResultFile {
  id            String   @id @default(uuid())
  resultId      String
  fileName      String
  filePath      String
  fileType      String
  fileSize      Int
  cloudinaryUrl String
  cloudinaryId  String
  uploadedAt    DateTime @default(now())
  
  // Soft delete fields
  isDeleted     Boolean  @default(false)
  deletedAt     DateTime?
  deletedBy     String?
  deletionReason String? // Optional reason for deletion
  
  result        ScreeningResult @relation(fields: [resultId], references: [id], onDelete: Cascade)
  deletedByStaff CenterStaff? @relation("StaffDeletedFiles", fields: [deletedBy], references: [id], onDelete: SetNull)
  
  @@index([isDeleted, resultId]) // For efficient filtering
}

model StoreProduct {
  id          String   @id @default(uuid())
  name        String
  description String?
  price       Float
  stock       Int
  createdAt   DateTime @default(now())
}

model Transaction {
  id                  String   @id @default(uuid())
  type                TransactionType
  status              TransactionStatus // change this to an enum with e.g., "PENDING", "COMPLETED", "FAILED"
  amount              Float
  relatedDonationId   String?
  paymentReference    String?
  paymentChannel      String?
  createdAt           DateTime @default(now())

  donation            DonationCampaign? @relation("DonationTransactions", fields: [relatedDonationId], references: [id], onDelete: SetNull)
  appointments Appointment[] @relation("TransactionAppointments")
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  profileType ProfileType
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String   @id @default(uuid())
  type      String
  title     String
  message   String
  data      Json?
  createdAt DateTime @default(now())
  recipients NotificationRecipient[]
}

model NotificationRecipient {
  id             String   @id @default(uuid())
  notificationId String
  userId         String
  read           Boolean  @default(false)
  readAt         DateTime?
  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CenterStaff {
  id        String   @id @default(uuid())
  centerId  String
  email     String  
  passwordHash String
  role      String?
  createdAt DateTime @default(now())

  center    ServiceCenter @relation(fields: [centerId], references: [id], onDelete: Cascade)
  verifications AppointmentVerification[] @relation("StaffVerifications")
  uploadedResults ScreeningResult[] @relation("StaffUploadedResults")
  deletedResultFiles ScreeningResultFile[] @relation("StaffDeletedFiles")
  resetTokens CenterStaffResetToken[]

  @@unique([centerId, email])
}

model CenterStaffInvite {
  id        String   @id @default(uuid())
  centerId  String
  email     String
  token     String   @unique
  expiresAt DateTime?
  acceptedAt DateTime?

  center    ServiceCenter @relation(fields: [centerId], references: [id], onDelete: Cascade)
}

model CenterStaffResetToken {
  id        String   @id @default(uuid())
  staffId   String
  token     String   @unique
  expiresAt DateTime

  staff     CenterStaff @relation(fields: [staffId], references: [id], onDelete: Cascade)
}
